Проведем анализ производительности полученных версий анализатора. В
качестве данных для тестирования возьмем выражения вида 
$\underbrace{2+2+2 \dots +2}_n$ для $n = 1 \dots 100$ с шагом 1. 
Для вычисления времени выполнения воспользуемся библиотекой \verb|time|
Python 3.9.5. Автоматизацию обеспечим с помощью библиотеки \verb|subprocess|.
Получим следующий код:
\inputminted{Python}{test.py}
Кроме того, отметим, что в ранее написанные программы были внесены некоторые
изменения для проведения эксперимента. Ознакомиться с ними
можно в приложении \ref{app:A}.

Ознакомиться с полным исходным кодом программы, осуществляющей
исследование производительности можно в приложении \ref{app:B}.

Для большей наглядности графики интерполированы полиномом с помощью функции
\verb|polyfit| библиотеки \verb|numpy|.

Ознакомиться с полным исходным кодом программы, осуществляющей
анализ полученных результатов можно в приложении \ref{app:C}.
Результаты исследования изображены на рис. 7:

Исследование показало, что использование абстрактных синтаксических
деревьев позволяет уменьшить время работы программы более чем в 5 раз, что
существенно заметно для выражений любой длины.

Также из графиков видно, что в рамках данной работы не удалось добиться большей
производительности при управлении памятью на основе регионов.
Тем не менее, она все еще может считаться более предпочительной ввиду
перечисленных ранее преимуществ.